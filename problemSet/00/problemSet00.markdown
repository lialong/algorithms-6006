# 0-1

$A=\{i+\binom{5}{i},i\in\Z且0 \le i \le 4\}$

$B=\{3i|i\in\{1,2,4,5\}\}$

化简可得

A={1，6，12，13，9}

B={3，6，12，15}

## (a) $A\cap B$

{6，12}

## (b)$|A\cup B|$

|{1, 3, 6, 9, 12, 13, 15}|=7

## (c)$|A-B|$

|{1, 13, 9}|=3

# 0-2

X为随机数，代表抛硬币3次，正面朝上的次数。

Y为随机数，代表投掷两个6面骰子，两个骰子的乘积。请计算下面期望值。

## (a) E[X]

$0:\frac {1} {8}$，$1:\frac {3} {8}$，$2:\frac {3} {8}$，$3:\frac {1} {8}$

1.5

## (b) E[Y]

| 乘积  | 概率   |
| --- | ---- |
| 1   | 1/36 |
| 2   | 2/36 |
| 3   | 2/36 |
| 4   | 3/36 |
| 5   | 2/36 |
| 6   | 4/36 |
| 8   | 2/36 |
| 9   | 1/36 |
| 10  | 2/36 |
| 12  | 4/36 |
| 15  | 2/36 |
| 16  | 1/36 |
| 18  | 2/36 |
| 20  | 2/36 |
| 24  | 2/36 |
| 25  | 1/36 |
| 30  | 2/36 |
| 36  | 1/36 |

(1+4+6+12+10+24+16+9+20+48+30+16+36+40+48+25+60+36)/36=12.25

## (c)E[X+Y]

E[X+Y]=E[X]+E[Y]=13.75

# 0-3

A=600/6, B=60 mod 42

## (a)$A\equiv B(mod 2)$

true

## (B)$A\equiv B(mod 3)$

false

## (B)$A\equiv B(mod 4)$

false

# 0-4

推断法证明：当$n\ge1，\sum_{i=1}^{n}i^3=[\frac {n(n+1)}{2}]^2$

当n=1时，$\sum_{i=1}^{n}i^3=1,[\frac {n(n+1)}{2}]^2=1$

假设n=k时，等式成立。$\sum_{i=1}^{k}i^3=[\frac {k(k+1)}{2}]^2$

当n=k+1时，

$\sum_{i=1}^{k+1}i^3=\sum_{i=1}^{k}i^3+(k+1)^3$

$[\frac {(k+1)(k+2)}{2}]^2=[\frac {k(k+1)} {2}+ (k+1)]^2=[\frac {k(k+1)}{2}]^2+k(k+1)^2+(k+1)^2=[\frac {k(k+1)}{2}]^2+(k+1)^3$

# 0-5

通过推断证实：每个连接的无向图G=(V,E)，当|E|=|V|-1时，它是无环的。

解：基于k个顶点推断。基本情形：包含1个点、0条边的图是无环的。

现在对于任意连通图（有k个点、k-1条边），假设这种情形时推断为真，考虑任意连通图G（有k+1个点、k条边）。G是连通的，因此每个点至少连了1条边。因为k条边中，每个都连接两个点，G中点的平均度是$2k/(k+1)<2$，因此至少存在一个点v，其度为1，连接着一个点u。移除v和连接v、u的边，得到图G''（有k个点、k-1条边，也是连通的）。点v不在图G的任何环中，因为环中的点，其度至少为2，因此仅当G''包含环时，G包含环。通过归纳假说，G''是无环的，因此G也是。

# 0-6

整数数组的升序子数组，是整数数组的连续序列（值升序）。写python函数count_long_subarrays(A)，接受Python数组（Tuple）A=($a_0,a_1,...,a_{n-1}$)，n>0个正数，返回A中最长升序子数组的数量，最长升序子数组的元素个数，至少比每个其它升序子数组的元素个数多。例如，如果A=(1,3,4,2,7,5,6,9,8)，你的程序应该返回2，因为A中升序子数组的最大长度为3，有两个升序子数组有该数量的元素，子数组：(1,3,4)和(5,6,9)。

```python
def count_long_subarrays(A):
    longest,length,num = 1,0,0
    last = A[0]
    for item in A:
        if item >= last:
            length += 1
            if length > longest:
                longest = length
                num = 1
            elif length == longest:
                num += 1
        else:
            length = 1
        last = item
    return num

if __name__ == "__main__":
    A = (1,3,4,2,7,5,6,9,8,9,10)
    print(count_long_subarrays(A))
```