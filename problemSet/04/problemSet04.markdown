# 4-1 二叉树练习（Binary Tree Practice）

## (a)

下面的Set Binary Tree T不是高度平衡的，但满足二叉搜索树属性，假设每个整数项的key都是其本身。指出所有高度不平衡的节点的key，并计算它们的偏斜。

![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/problemSet/04/1.png)

解：包含键16和37的节点没有高度平衡。它们的偏斜度分别为2和-2。

## (b)

在T上依次执行以下插入和删除操作，通过添加或删除叶子保持二叉搜索树属性（可能需要将一个键向下交换到一个叶子中）。对于此部分，不要使用旋转来平衡树。每次操作后绘制修改后的树。

T.insert(2)
T.delete(49)
T.delete(35)
T.insert(85)
T.delete(84)

![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/problemSet/04/2.png)

![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/problemSet/04/3.png)

## (c)

对于（a）部分中确定的每个不平衡节点，绘制两棵树，这两棵树是通过在原始树中左右旋转节点而产生的（如果可能）。对于绘制的每棵树，表明其是否高度平衡，即所有节点都满足AVL属性。

![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/problemSet/04/4.png)

# 4-2 堆练习（Heap Practice）

对于下面的每个数组，将其绘制为完全“二叉树”，并说明树是最大堆、最小堆还是两者都不是。如果树两者都不是，则通过反复交换树中相邻的项目将树转换为最小堆。通过绘制一系列树来传达你的交换，在每棵树上标记交换的对。

![](C:\Users\lizelong\AppData\Roaming\marktext\images\2024-08-30-16-20-39-image.png)

# 4-3 园艺比赛（Gardening Contest）

园艺公司Wonder Grow每年都会赞助一场全国性的园艺比赛，在比赛中，他们用正整数对全国各地的花园进行评分。由花园对$(s_i,r_i)$标明的花园，其中$s_i$是花园分配的分数，$r_i$是花园的唯一正整数注册号。

## （a）

为了支持包容性并减少竞争，Wonder Grow希望授予前k个花园相同的奖杯。给定一个未排序的花园对数组A，正整数$k\le|A|$，描述一个$O(|A|+klog|A|)$时间复杂度算法来返回A中得分最高的花园注册号。
解：根据数组A构建最大堆（以花园得分$s_i$为key），这可以在$O(|A|)$时间内完成。然后使用delete_max()重复删除最大配对k次，并返回配对的注册号。因为最大堆正确地从中删除了一些最大值，每次删除花费$O(log|A|)$，此算法是正确的，总共耗费$O(|A|+klog|A|)$。

## (b)

Wonder Grow决定更加客观，并为每个得分严格高于参考得分的花园颁发奖杯。给定花园对的最大堆A，描述一个$O(n_x)$时间复杂度算法，返回得分大于x的所有花园的注册号，其中$n_x$是返回的花园数。

解：对于这个问题，我们无法负担$O(n_x log|A|)$的时间从A中重复删除最大值，直到删除的对的得分小于或等于x。但是，我们可以利用最大堆属性，只遍历包含最大$n_x$对的最大堆的子集（包含$O(n_x)$个元素）。首先观察到最大堆属性，意味着所有$n_x$个键大于x的项形成包含根的堆的连通子树（假设任何存储的分数都大于x）。因此，递归地从根开始搜索堆的节点v。有两种情况：

v处的分数$\le x$，因此返回一个空集，因为根据max堆属性，v子树中不应返回任何对

v处的分数$>x$，因此递归搜索v的子项（如果存在），并将v处的分数与递归调用返回的分数一起返回（通过归纳法得知是正确的）。

这个程序最多访问$3n_x$节点(这些节点包含$n_x$个项目，以及每个节点的2个子节点)，因此这个程序耗费$O(n_x)$。

# 4-4 太阳能（Solar Supply）

企业家Bonty Murns在Fallmeadow镇拥有一套太阳能发电厂。每个太阳能发电场$(s_i,c_i)\in S$由一个唯一的正整数地址$s_i$和一个发电场容量$c_i$指定：正整数，对应发电场可以支持的最大能源生产率。Fallmeadow的许多建筑都需要电力。建筑物$(b_j,d_j)$由唯一的名称字符串$b_j$和需求$d_j$：正整数对应建筑的能耗率。

为了获得电力，Fallmeadow的建筑必须连接到一个太阳能发电场，限制条件是，对于任何太阳能发电厂$s_i$，与$s_i$相连的所有建筑物的需求总和不能超过农场的容量$c_i$。描述一个支持以下操作的数据库，每个操作，明确您的运行时间是最坏的情况、预期的、还是摊销的。

![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/problemSet/04/6.png)

我们的解法将维持以下数据结构：

太阳能发电场上的优先级队列P，为每个太阳能发电场存储其地址$s_i$、容量$c_i$及其可用容量$a_i$（初始$a_i=c_i$），以可用容量为key；

集合数据结构B，将每个供电建筑的名称$b_j$映射到它所连接的太阳能发电场$s_i$的地址及其需求$d_j$

集合数据结构F，将每个太阳能发电场$s_i$的地址映射到：（1）其自己的集合数据结构$B_i$，其中包含与该发电场相关联的建筑物，以及（2）指向$s_i$在P中的位置的指针

现在我们支持操作：

$initialize(S)$：由S构建集合数据结构P和F，并将上述所有其他数据结构初始化为空。此操作通过简化为构建F和P来直接维护数据库的不变量。有$O(n)$个空数据结构和指针被构造，因此如果我们用可以在$O(n)$时间内构建的数据结构来实现P和F，则此操作也将花费$O(n)$时间。

$power\_on(b_j, d_j)$：假设$b_j$尚未连接到电源（否则操作未指定）。首先，通过从P中删除具有最大可用容量$c_i$的太阳能农场$s_i$（使用delete_max），并检查其容量是否至少为$d_j$来找到一个要连接的太阳能农场。有两种情况：

$d_j > c_i$，所以将太阳能农场重新插入P中（重新链接指针：从F到P中某位置），并返回当前没有太阳能农场可以支持该建筑。

$d_j\le c_i$，所以从$c_i$中减去$d_j$并重新将其插入P中（重新链接指针）。然后，将$b_j$映射$s_i$添加到的B中，并在F中找到与$s_i$相关联的$B_i$，将$b_j$添加到$B_i$中。此操作直接维持数据库的不变性，并花费的时间复杂度上限是：在P上的一次delete max操作和一次insert操作，在B上的一次insert操作，在F上的一次find操作，一次$B_i$的插入，以及常数的额外工作（以维护指针和执行算术运算）。

$power\_off(b_j)$：假设$b_j$已经连接到电源（否则操作未指定）。在B中查找与$b_j$相关联的$s_i$和$d_j$，使用$s_i$在F中查找$B_i$，并从$B_i$中移除$b_j$。最后，去P中$s_i$的位置，从P中移除$s_i$，将$c_i$增加$d_j$，并将$s_i$重新插入P中。此操作直接维持数据库的不变性，并花费的时间复杂度上限是：在B中的一次lookup操作，在F中的一次lookup操作，在$B_i$中的一次delete操作，在P中按位置的一次remove操作，在P中的一次insert操作，以及常数的额外工作。

$customers(s_i)$：使用$s_i$在F中查找$B_i$，并返回存储在$B_i$中的所有名称。此操作基于数据结构维护的不变性是正确的（$B_i$包含与$s_i$相关联的建筑），并花费的时间复杂度上限是：在F中的一次lookup操作和一次遍历$B_i$的操作。

我们已经证明了该数据库可以正确地支持这些操作。现在，我们选择数据库中的数据结构的实现方式，以便使操作变得高效。我们需要能够在$O(n)$时间内构建B和F，并支持$O(logn)$的查找，因此我们必须使用哈希表来实现这些，导致所有操作具有预期的界限，而power_on和power_off具有平均界限。对于每个$B_i$，我们需要$O(logn)$的查找、插入和删除，因此可以使用AVL树或哈希表来实现。最后，P需要$O(n)$复杂度的构建，$O(log n)$复杂度的插入和删除最大值，可以使用最大堆（Max-Heap）或带有子树最大项增强的序列AVL树（Sequence AVL Tree）。请注意，通过指向节点的指针从序列AVL树中删除元素与通过索引找到元素后再删除是完全相同的。通过索引从最大堆中删除元素并不是原生支持的，但使用了与删除根节点相同的技术：将元素与最后一个叶子节点（数组中的最后一个元素）交换，删除该元素，然后将移动的元素在树中向上或向下移动以恢复最大堆属性。。

# 4-5 Robot Wrangling

Dr. Squid构建了一个由n+1个刚性杆或称为链接的机器人手臂，每个链接都通过旋转关节与前一个链接相连，总共有n个关节。这是机器人技术中的常见做法，其中每个链接的方向都是相对于前一个链接的方向局部指定的。在数学表示中，这可以表示为一个4x4的变换矩阵数组。$M=(M_0,...,M_{n-1})$是与手臂关节相关联的变换矩阵的数组。矩阵$M_k$是关节$k$处方向的改变，处于链接k和k+1之间。

为了计算末端执行器的位置，Dr. Squid需要评估手臂的完整变换矩阵乘积。手臂变换矩阵的有序乘积可以写为$\prod_{k=0}^{n-1}=M_k=M_0*M_1*...*M_{n-1}$。

假设Dr. Squid有一个函数`matrix_multiply(M1, M2)`，该函数可以在O(1)时间内返回任意两个4x4变换矩阵的乘积。当他在调整手臂，每次改变一个关节时，Dr. Squid需要快速重新评估这个矩阵乘积。

为了加速Dr. Squid的工作流程，他需要一个数据库来支持以下最坏情况下的操作：

![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/problemSet/04/7.png)

解：在序列AVL树T中存储矩阵，其中每个节点v存储一个矩阵v.M，并通过v.P进行扩展：v.P是v的子树中所有矩阵的顺序乘积。在节点v处的这个属性可以通过其子节点的扩展在O(1)时间内计算得出。

特别地，设PL和PR分别为v的左孩子和右孩子的P值（如果相应的左孩子或右孩子不存在，则为4x4单位矩阵）；然后v.P = PL · v.M · PR，这可以在O(1)时间内使用提供的matrix_multiply函数计算得出，因此这种增强可以被维护。（注意，由于项目数量和遍历顺序永远不会改变，所以在这里不需要AVL行为，因为没有操作会改变树的结构。因此，一个静态二叉树，甚至是一个隐式表示的、存储在数组中的完全二叉树（如二叉堆）就足够了。）

现在，我们支持以下操作：

$initialize(M)$：在最坏情况下，从M中的矩阵构建T，时间复杂度为$O(|M|) = O(n)$，同时从叶子节点到根节点维护新的增强。

$update_joint(k, M)$：使用在T的根节点处的$get_at(k)$在$O(log n)$时间内找到遍历顺序中包含矩阵k的节点v，并用M替换v.M。然后，在$O(log n)$时间内重新计算树上的增强。

$full transformation()$：存储在T的根节点处的增强正好对应于手臂的完全变换，因此只需在$O(1)$时间内返回T.root.P。

# 4-6 $\pi z^2a$ Optimization