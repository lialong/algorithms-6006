# 一、上次与今日目标

<div>
<table>
    <tr>    
        <td rowspan=3>序列数据结构</td>
        <td colspan=5 align="center">操作，最坏情形O</td>    
    </tr>
    <tr>
        <td>容器（container）</td>
        <td>静态（static）</td>
        <td colspan=3 align="center">动态（dynamic）</td>
    </tr>
    <tr>
        <td>build(x)</td>
        <td>get_at(i)<br>set_at(i, x)</td>
        <td>insert_first(x)<br>delete_first()</td>
        <td>insert_last(x)<br>delete_last()</td>
        <td>insert_at(i, x)<br>delete_at(i)</td>
    </tr>
    <tr>
        <td>二叉树</td>
        <td>n</td>
        <td>h</td>
        <td>h</td>
        <td>h</td>
        <td>h</td>
    </tr>
    <tr>
        <td>AVL树</td>
        <td>n</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
    </tr>
</table>
</div>

<div>
<table>
    <tr>    
        <td rowspan=3>集合数据结构</td>
        <td colspan=5 align="center">操作，最坏情形O</td>    
    </tr>
    <tr>
        <td>容器（container）</td>
        <td>静态（static）</td>
        <td>动态（dynamic）</td>
        <td colspan=2 align="center">顺序（order）</td>
    </tr>
    <tr>
        <td>build(X)</td>
        <td>find(k)</td>
        <td>insert(x)<br>delete(k)</td>
        <td>find_min()<br>find_max()</td>
        <td>find_prev(k)<br>find_next(k)</td>
    </tr>
    <tr>
        <td>二叉树</td>
        <td>nlogn</td>
        <td>h</td>
        <td>h</td>
        <td>h</td>
        <td>h</td>
    </tr>
    <tr>
        <td>AVL树</td>
        <td>nlogn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
        <td>logn</td>
    </tr>
</table>
</div>

# 二、高度平衡

* 如何维持高度$h=\mathcal{O}(\log n)$，n为树中节点的数量

* 在动态操作中维持树的高度为$\mathcal{O}(\log n)$的二叉树称为平衡的
  
  * 有多种平衡方式（红黑树、伸展树SplayTree、2-3Tree）
  
  * 首次提出平衡策略的是AVL树

# 三、旋转（Rotations）

* 需要降低树的高度，而不改变遍历顺序，因此我们表示相同序列的项目

* 保留遍历顺序时，如何改变树的结构？旋转！

```mermaid
graph TB;
    D-->B;
    D-->E;
    B-->A;
    B-->C;
```

```mermaid
graph TB;
    B-->A;
    B-->D;
    D-->C;
    D-->E;
```

图1 rotate_right(\<D\>) 得到图2、图2 rotate_left(\<B\>) 得到图2

* 旋转重新链接$\mathcal{O}(1)$指针更改树结构、维持遍历顺序

# 四、Rotations Suffice

* 声明：$\mathcal{O}(n)$次旋转可以转换二叉树为任意其他二叉树（拥有相同遍历顺序）

* 证明：按遍历顺序重复执行最后可能的右旋；结果树为经典的链表。每次旋转最后节点的深度增加1。最终链中最后节点的深度为$n-1$，因此最多执行n-1次旋转。反向旋转得到目标树

* 通过使用$\mathcal{O}(n)$次旋转，可以维持高度平衡来完全平衡二叉树，但很慢

* 每次操作，我们将耗时$\mathcal{O}(\log n)$维持树的平衡

# 五、AVL树：高度平衡

* AVL树维持高度平衡（也称作AVL属性）
  
  * 如果左、右子树高度最多相差1，那么节点是高度平衡的
  
  * 让节点的偏斜为右子树高度减左子树高度
  
  * 如果它的偏斜为-1、0、1，那么节点是高度平衡的

---

* 声明：拥有高度平衡节点的二叉树，高度为$h=\mathcal{O}(\log n)，比如n=2^{\Omega(h)}$

* 证明：任意高度为h的树，最少节点$F(h)=2^{\Omega(h)}$
  
  F(0)=1，F(1)=2，F(h)=1+F(h-1)+F(h-2) >= 2F(h-2) => $F(h)\ge2^{h/2}$

---

* 假设从高度平衡树中添加或删除叶子导致不平衡
  
  * 仅叶子祖先的子树高度改变或歪曲
  
  * 改变高度仅为1，因此倾斜幅度$\le$2
  
  * 点子：从叶子到根，修复祖先的高度平衡
  
  * 重复地再平衡（高度不平衡的）最低祖先

* 本地再平衡：给定二叉树节点\<B\>：
  
  * 倾斜为2且
  
  * \<B\>子树的每个其他节点是高度平衡的，
  
  * \<B\>的子树可以通过一次或2次旋转达到高度平衡
  
  * （之后，\<B\>的高度将等于或小于之前的高度）

* 证明：
  
  * 因为B的倾斜是2，所以\<B\>的右子树\<F\>存在
  
  * case1:\<F\>的倾斜是0、或case2：\<F\>的倾斜是1
    
    * 在\<B\>上执行左旋
    
    ![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/lecture/07/1.png)
    
    * 让h=height(\<A\>)，那么height(\<G\>)=h+1，并且height(\<D\>)是h+1(case1)或h(case2)
    * 旋转后：
      * \<B\>的倾斜要么是1(case1)，要么是0(case2)，因此\<B\>是高度平衡的
      * \<F\>的倾斜是-1或0，因此\<F\>是高度平衡的
      * 子树的高度之前是h+3，之后为h+3(case1)、h+2(case2)
  
  * case3：\<F\>的倾斜是-1，因此\<F\>的左子节点\<D\>存在
    
    * 在\<F\>上执行右旋，然后在\<B\>上执行左旋
    
    ![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/lecture/07/2.png)
    
    * 让h=height(\<A\>)。那么height(\<G\>)=h，height(\<C\>)和height(\<E\>)是h或h-1
    * 旋转后：
      * \<B\>的倾斜是0或-1，因此\<B\>的高度是平衡的
      * \<F\>的倾斜是0或1，因此\<F\>的高度是平衡的
      * \<D\>的倾斜是0，因此D是高度平衡的
      * 子树的高度之前是h+3，那么之后是h+2

* 全局再平衡：从高度平衡树T中添加或删除一个叶子生成树T'。然后T‘可以使用至多$\mathcal{O}(\log n)$次旋转转换成一个高度平衡树T''

* 证明：
  
  * 仅受影响叶子的祖先，T'比T有不同的高度
  
  * 受影响叶子至多$h=\mathcal{O}(\log n)$个祖先（它的子树可能已经改变）
  
  * 让\<X\>为最低的高度不平衡祖先（倾斜度是2）
  
  * 如果一个叶子加到T：
    
    * 插入增加\<X\>的高度，因此是不平衡的case2或case3
    
    * 旋转降低子树的高度：1次旋转后平衡
  
  * 如果叶子从T中移除：
    
    * 删除使\<X\>子节点的高度降低1，并非\<X\>，因此不平衡
    
    * 可能让\<X\>的高度降低1；\<X\>的父级可能变不平衡
    
    * 因此可能不得不再平衡\<X\>的每个祖先，但至多它们中的h=$\mathcal{O}(\log n)$个

* 因此，在插入/删除之后，仅使用$\mathcal{O}(\log n)$次旋转就可以维持高度平衡

* 但需要我们评估$\mathcal{O}(\log n)$个节点是否是高度平衡的

# 六、计算高度

* 如何得知节点\<X\>是高度平衡的？计算子树的高度！

* 如何计算节点\<X\>的高度？直接的算法：
  
  * 递归地计算\<X\>左右子树的高度
  
  * 两个高度中的最大值加1
  
  * 运行时间为$\Omega(n)$，因为我们在每个节点上递归

* 点子：在每个节点处增加其子树的高度

* 在动态操作期间，我们必须随着树改变形状维持扩张

* 在每个节点的子树改变时，重新计算子树的扩张
  
  * 对在旋转操作中重新链接的点进行更新，花费$\mathcal{O}(1)$，祖先不改变
  
  * 通过向上遍历树，更新插入/删除节点的所有祖先，花费$\mathcal{O}(h)$

# 七、扩充二叉树的步骤

* 通常，用子树属性P来扩充二叉树，你必须：
  
  * 声明子树属性P(\<X\>)，你想在每个节点\<X\>处存储它
  
  * 展示如何花费$\mathcal{O}(1)$,从\<X\>的孩子的扩展中计算P(\<X\>)

* 那么存储的属性P(\<X\>)可以被维持，不会改变动态操作的消耗

# 八、应用：序列

* 对于序列二叉树，我们需要知道子树尺寸

* 插入/删除叶子，这是简单的，但现在需要处理旋转

* 子树的尺寸是一个子树属性，因此可以通过扩展进行维持
  
  * 可以通过孩子的尺寸来计算，把孩子尺寸相加，并加1

# 九、总结

* AVL树，对所有集合操作，实现花费$\mathcal{O}(\log n)$，除了构建:$\mathcal{O}(n\log n)$，遍历:$\mathcal{O}(n)$

* AVL树，对所有序列操作，实现花费$\mathcal{O}(\log n)$，除了构建:$\mathcal{O}(n)$，遍历:$\mathcal{O}(n)$

# 十、应用：排序

* 任意集合数据结构定义了一个排序算法：构建(重复地插入)、遍历

* 举例：lecture5中的直接访问数组

* AVL排序是一个新的$\mathcal{O}(n\log n)$时间复杂度的排序算法

# 十一、Recitation

## 平衡的二叉树

之前，我们讨论二叉树作为一个通用数据结构，用于存储项目，不会限制树的最大高度。最终目的变为：保持我们的树平衡，如果高度为$\mathcal{O}(\log n)$，n节点的树是平衡的。那么所有我们上次讨论的花费$\mathcal{O}(h)$时间的操作，将仅花费$\mathcal{O}(\log n)$。

有许多种方式，在插入和删除时，来维持二叉树的平衡（红黑树、B-树、2-3树、伸展树等等）。最早（可能也是最简单的）的方式称作AVL树。AVL树上的每个节点都是高度平衡的（满足AVL属性），高度平衡节点的左右子树，其高度最多相差1。另外的表达，定义斜率为：右子树的高度-左子树的高度，空子树的高度为-1。若它的斜率是-1、0、1，那么这个节点是高度平衡的。若树的每个节点是高度平衡的，则树是高度平衡的。高度平衡是好的，因为它意味着平衡。

### 练习

高度平衡的二叉树是平衡的

解法：平衡意味着：h=$\mathcal{O}(\log n)$。等价得，平衡意味着logn以$\Omega(h)$为下界，因此$n=2^{\Omega(h)}$。如果我们可以展示，高度平衡树的最小的节点数，至少为h指数次方，那么它必定是平衡的。让F(h)为任意高度平衡树(高度为h)的最少节点。那么F(h)满足以下递归：

F(h)=1+F(h-1)+F(h-2)>=2F(h-2)

因为根的子孙的子树应该也包含最少的节点。基于基础情形，高度平衡树(高度为0)的最少节点为1，F(0)=1，高度平衡树(高度为1)的最少节点为2，F(1)=2。那么这个递归的下边界为：

$F(h)>=2^{h/2}=2^{\Omega(n)}$

## 旋转

当我们对树添加或删除节点时，可能：我们的树将变得不平衡。我们想要改变树的结构，而不改变它的遍历顺序，希望我们能让树的结构更平衡。我们能用局部操作——旋转，改变树的结构。子树发生的旋转，看起来就像下面的两个配置，花费$\mathcal{O}(1)$更改节点之间的连接，从一个配置转换为另外一个配置。
![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/lecture/07/3.png)