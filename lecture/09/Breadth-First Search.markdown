# 一、新单元：图

* Quiz 1包含lecture01到lecture08，关注数据结构和排序

* 今天开始新单元，lecture09-lecture14，关注图算法

# 二、图应用

* 图无处不在

* 任何网络系统都存在有向连接图

* 比如：路网、计算机网络、社交网络

* 任何离散系统的状态空间都可以用过渡图表示

* 比如：puzzle & games like Chess, Tetris, Rubik’s cube

* 比如：应用流，声明

# 三、图定义

![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/lecture/09/1.png)

* 图$G=(V,E)$是一组点V和一组顶点的对$E\subseteq V\times V$

* 有向边是有序对，比如，$(u,v)，u,v \in V$

* 无向边是无序对，比如，$\{u,v\}，u,v\in V$，比如：$(u,v)和(v,u)$

* 在这个类中，我们假设所有图是简单的：
  
  * 边是去重的，比如(u,v)仅在E（尽管(v,u)可能出现）中出现一次，并且
  
  * 边是非重复点的组合，比如：$u\ne v，(u,v)\in E$
  
  * 意味着：$|E|=\mathcal{O}(|V|^2)$，因为无向：$|E|\le\binom{|V|}{2}$，有向：$\le2\binom{|V|}{2}$

# 四、邻居集和邻接

* $u\in V，u的出向相邻：Adj^+(u)=\{v\in V|(u,v)\in E\}$

* $u\in V，u的入向相邻：Adj^-(u)=\{v\in V|(v,u)\in E\}$

* 顶点u的出度，$u\in V，deg^+(u)=|Adj^+(u)|$

* 顶点u的入度，$u\in V，deg^-(u)=|Adj^-(u)|$

* 对于无向图，$Adj^-(u)=Adj^+(u)，deg^-(u)=deg^+(u)$

* 删除上标默认是出向，比如，$Adj(u)=Adj^+(u)，deg(u)=deg^+(u)$

# 五、图的表达

* 为了存储图$G=(V,E)$，我们需要存储外向边$Adj(u)，u\in V$

* 首先，需要一个集合数据结构$Adj$来映射u到$Adj(u)$

* 然后对于每个u，需要存储$Adj(u)$到其他数据结构——邻接表

* 通常对Adj使用直接访问数组或哈希表，因为想通过顶点快速查找

* 通常对每个Adj(u)使用数组或链表，因为通常只需要迭代

* 通用表达：$Adj尺寸为\Theta(|V|)，每个Adj(u)尺寸为\Theta(deg(u))$

* 因为由handshaking lemma得知$\sum_{u\in V}deg(u)\le2|E|$，图存储空间为$\Theta(|V|+|E|)$

* 因此，对于图算法，线性时间意味着$\Theta(|V|+|E|)$，与图尺寸呈线性

# 六、举例

* 例1和例2假设顶点标记为$\{0,1,...,|V|-1\}$，因此可以对Adj使用直接访问数组，存储Adj(u)到数组。例3对Adj使用哈希表。

![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/lecture/09/2.png)

* 注意在无向图中，连接是对称的，因为每个边算作两次出向

# 七、路径

* 路径是点的序列$p=(v_1,v_2,...,v_k)，(v_i,v_{i+1})\in E，1\le i\lt k$

* 如果没有重复点，路径是简单的

* 长度$l(p)$是路径p中边的个数

* 距离$\delta(u,v),从u\in V到v \in V$，表示u到v之间所有路径长度的最小值，比如：从u到v之间最短路径的长度，（按照惯例，$\delta(u,v)=\infty$，如果u与v不相连）

# 八、图路径问题

* 有许多你可能想解决的，与图路径有关的问题

* SINGLE_PAIR_REACHABILITY(G, s, t)：G中是否存在路径，从$s\in V到t \in V$

* SINGLE_PAIR_SHORTEST_PATH(G, s, t)：返回距离$\delta(s,t)$，以及$G=(V,E)$中从$s\in V到t \in V$最短路径

* SINGLE_PAIR_SHORTEST_PATHS(G,s)：返回$\delta(s,v)，v\in V$，以及一个最短路径树（包含从s到每个$v\in V$的最短路径）

* 上面的每个问题都至少和上面的每个问题一样难，解决完一个低级问题，可以把它当作黑盒来解决任意更高级的问题

* 不会展示算法来解决所有这些问题

* 而是，展示一个算法，耗时$\mathcal{O}(|V|+|E|)$来解决最难的

# 九、最短路径树

* 对于图中每个顶点，如何从源点s返回一条最短路径？

* 一些路径有长度$\Omega(|V|)$，因此返回每条路需要$\Omega(|V|^2)$

* 对于所有$v\in V$，存储它的parent $P(v)$，从s出发最短路径上第二个到最后一个点

* 让P(s)为null（从s到s，最短路径上没有第二个到最后一个点）

* parent集合构成了最短路径树，尺寸为$\mathcal{O}(|V|)$
  
  （例如，从每个点（s点可达）来返回到s的反向最短路径）

# 十、广度优先查找（BFS）

* 如何计算$\delta(s,v)$和$P(v)$，$v\in V$？

* 存储$\delta(s,v)$和$P(v)$到集合数据结构，对应点v距离和parent

* 如果没有路径从s都v，不会存储v到P中，并设$\delta(s,v)=\infty$

* 按距离升序探索图中点

* 目标：计算层级集合$L_i=\{v|v\in V且d(s,v)=i\}$，所有点位于距离i

* 声明：每个点$v\in L_i$，必须与点$u\in L_{i-1}$相邻（比如，$v\in Adj(u)$）

* 声明：在$L_j$（j<i）中的点，不会出现在$L_i$

* 不变性：对于$L_j$中所有点，$\delta(s,v)$和$P(v)$已经正确计算过了

* 基本情形（i=1）：$L_0=\{s\},\delta(s,s)=0,P(s)=None$

* 推断步骤：计算$L_i$：
  
  -$L_{i-1}$中每个顶点u
  
    -每个顶点$v\in Adj(u)$（v没有出现在$L_j$中，j<i）
  
     -添加v到$L_i$，设置$\delta(s,v)=i，P(v)=u$

* 重复地计算$L_j$到$L_i$（j<i），提升i直到$L_i$是空集

* 对于$v\in V$，$\delta(s,v)$没有被设置的点，$\delta(s,v)=\infty$

* 通过推断，广度优先查找正确地计算所有$\delta(s,v)$和$P(v)$

* 运行时间分析：
  
  * 存储每个$L_i$到数据结构中，需要$\Theta(|L_i|)$迭代，$\mathcal{O}(1)$插入（比如动态数组和链表）
  
  * 通过检查v是否在P中，来检查点v在不在$L_j,j<i$
  
  * 维护$\delta$和$P$在集合数据结构中，支持字典操作耗时$\mathcal{O}(1)$（直接访问数组或哈希表）
  
  * 算法添加每个顶点u到level中，对每个$v\in Adj(u)$花费$\mathcal{O}(1)$
  
  * 由handshake lemma得知，工作上边界：$\mathcal{O}(1)\times \sum_{u\in V}deg(u)=\mathcal{O}(|E|)$
  
  * 最后，花费$\Theta(|V|)$，为s不可达顶点$v\in V$，赋值$\delta(s,v)$
  
  * 因此广度优先查找运行时间是线性的！$\mathcal{O}(|V|+|E|)$

* 从例3图中点s出发，运行广度优先查找

# 十一、Recitation

## 图

图$G=(V,E)$是一个数学对象，由顶点V和边E的集合组成，E中的每个边，都是顶点V的双元素子集。如果边包含点，顶点和边是相邻的。u和v为顶点，如果它的子集对是有序的，那么边是有向的，比如$(u,v)$，如果子集对是无序的，则为无向边，比如$\{u,v\}$，也可以是$(u,v)$和$(v,u)$。有向边$e=(u,v)$，从顶点u（e的尾）到顶点v（e的头），边e是v的入边，是u的出边。在无向图中，每个边既是入又是出。顶点v的入度和出度，分别对应v的入边数量和出边数量。除特殊说明，我们说起度数，通常意味着出度。

正如名字（图）所暗示的那样，图通常是图形化描述的，顶点画作点，边画作连接点的线。如果边是有向的，它对应的线也包含边方向的指示，比如通过一个边的箭头。下面的例子是有向图G1和无向图G2。

![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/lecture/09/3.png)

图中的路径是一串顶点$(v_0,...,v_k)$，对于每个有序的顶点对$(v_i,v_{i+1})$，图中存在一个出向边从$v_i$到$v_{i+1}$。路径的长度是路径中边的数量，或是点的数量-1。如果图中每个点到每个其它点都存在路径，称之为强连接的。每个连接的无向图都是强连接的，因为每个与点相邻的无向边都是出向的。有向图G1的两部分，仅1个是强连接的。

## 图的表示

代码中有很多方式表示图。最常用的方式是存储一个集合数据结构Adj，映射每个顶点u到另外的数据结构$Adj(u)$（存储v的邻接点），从v出发，可通过单向出边访问的一组顶点。这个内部数据结构称为邻接表。我们不显示的存储边，我们仅储存每个顶点的外向邻接点。当顶点从$0$到$|V|-1$标注时，通常用长度为$|V|$的直接访问数组存储顶级集合Adj，数组槽位i指向标有i的顶点的邻接表。如果顶点不是以这种方式标注，通常使用哈希表来映射每个$u\in V$到$Adj(u)$。通常将每个邻接表$Adj(u)$存储为出向邻接点的无序数组。比如，下面是表示$G_1$和$G_2$的邻接表，用直接访问数组作为顶级集合，每个邻接表一个数组。

![](https://raw.githubusercontent.com/lialong/algorithms-6006/main/lecture/09/4.png)

使用数组作为邻接表是一种完美的数据结构，如果你需要做的是在顶点相邻的边上循环（本课程中所有这种场景的算法，会默认是这么实现的）。每个边在邻接表中至多出现2次，因此使用数组实现邻接表的尺寸是$\Theta(|V|+|E|)$。这种表示方式的缺点是，判断图中是否包含给定边$(u,v)$，可能需要$\Omega(|V|)$时间来遍历u或v的邻接表数组。我们可以通过用哈希表来存储（而不是无序数组）邻接表，克服这个障碍，支持边检测耗费预期的$O(1)$，仍然仅使用$\Theta(|V|+|E|)$空间。然而我们的算法不需要这个操作，因此我们将假定：更简单的无序数组相邻表表示。下面是使用哈希表用作外部${Adj}$集合和内部邻接表$Adj(u)$的$G_1$和$G_2$的表示，使用python dictionary。