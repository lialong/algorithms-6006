# Problem 1：餐厅排队

受欢迎的餐厅Criminal Seafood不支持预定，而是维护一个等待表（客户等的时间越久，越早入座）。有时客户决定吃其他的，因此餐厅必须把他们从等待表中移除。假设每个客户有不同的姓名，不会有：同一时间2个客户添加到等待表的。设计一个数据库来帮助Criminal Seafood维护它的等待表，支持下面操作，每个耗费$O(1)$。表明每个操作运行时间是最坏的、分摊的、期望的。

<div>
    <table>
    <tr>
        <td>build()</td>
        <td>初始化空数据库</td>
    </tr>
    <tr>
        <td>add_name(x)</td>
        <td>添加姓名x到等待表的后面</td>
    </tr>
    <tr>
        <td>remove_name(x)</td>
        <td>从等待表中移除名称x</td>
    </tr>
    <tr>
        <td>seat()</td>
        <td>从等待表的前面删除、返回客户姓名</td>
    </tr>
    </table>
</div>

维护一个双端链表包含客户（按等待表顺序），维护一个指针指向链表头部，对应等待表的头部，维护一个指针指向链表尾部，对应等待表尾部。也维护一个哈希表，映射每个客户名到包含该客户的链表节点。为了实现add_name(x)，创建包含名称x的新链表节点，将其添加到链表尾部，耗费最坏情形$O(1)$。添加名称x到哈希表，指向最新创建的节点，耗费分摊的、期望的$O(1)$。为了实现remove_name(x)，在哈希表中查找名称x，并从链表中移除对应节点，期望耗费$O(1)$。最后，为了实现seat()，从链表头部移除节点（名称为x），从哈希表中移除名称x，返回x，耗费分摊的、期望的$O(1)$.

# Problem 2：降雨调研

Mether Wan是一个科学家（研究全球降雨）。Mether经常从大量传感器中接收观测数据。每个收集到的观测数据是一个整数三元组$(r,l,t)$，r是在时间t、纬度l处的正数降雨量观测值。自从时间t，纬度$l$处的巅峰降雨量是：大于等于时间t，纬度$l$处，所有观测降雨量的最大值（如果没有这个观测值则为0）。描述一个数据库，存储Mether的传感器数据，支持下面操作，每个耗费最坏情形$O(logn)$，n是执行该操作时，数据库中观测数据的数量。

<div>
<table>
    <tr>
        <td>build()</td>
        <td>初始化空数据库</td>
    </tr>
    <tr>
        <td>record_data(r,l,t)</td>
        <td>新增在时间t、纬度l的降雨量观测数据r</td>
    </tr>
    <tr>
        <td>peak_rainfall(l,t)</td>
        <td>返回自从时间t之后，纬度l处的最大降雨量</td>
    </tr>
</table>
</div>

维护一个集合AVL树L，存储不同纬度的观测数据，每个纬度$l$映射一个降雨量集合AVL树$R(l)$，包含纬度$l$处所有观测数据3元组，以时间为key。我们仅存储与观测数据相关的节点，因此每个集合AVL树的高度是由$O(logn)$限制的。对每个降雨量树，给每个节点p增加最大降雨量p.m（p的子树中观测量最大值）。节点p处的这个值可以耗费常量时间维护（取自p节点处降雨量、p左右子节点处观测量最大值，3者中最大值）。因此这个增加值可以被维护，而不会影响标准AVL树操作的渐进运行时间。

为了实现record_data(r,l,t)，在L中查纬度l，耗费最坏情形$O(logn)$。如果$l$不存在于L，插入新节点对应$l$（关联一个新的空降雨量集合AVL树），也耗费$O(logn)$。另外一种情况，插入观测数据三元组到$R(l)$，总计最坏情形运行时间为$O(logn)$。

为了实现peak_rainfall(l,t)，在L中查找纬度$l$耗费最坏情形$O(logn)$。如果$l$不存在，返回0。否则，在$R(l)$上执行查询，找出自从时间t，在纬度$l$上的最大降雨量。特别地，让$peak(v, t)$为自时间t之后，节点v子树中所有观测值的最大值。（v不是一个节点时，返回0）

$peak(v,t)=\begin{cases}max\{v.item,v.right.m,peak(v.left,t)\}\text{ if v.t}\ge t\\peak(v.right,t)\text{ if v.t}\lt t \end{cases}$

巅峰降雨量是$peak(v,t)$，v是树的根，使用至多$O(logn)$次递归调用得到。因此操作运行时间最坏情形耗费$O(logn)$。

注意，这个问题也可以通过每个纬度树，降雨量作为key来解决，节点处增加子树中的最大时间。
