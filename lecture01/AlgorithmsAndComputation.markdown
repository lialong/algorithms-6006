# 一、问题

1、问题输入到正确输出的二元关系。
2、通常不需要对所有输入明确正确输出。
3、提供一个可验证的预测，正确输出必须满足。
4、6.006基于大量通用输入，研究问题。
5、非通用：小输入实例
样例：在此教室中，有一对学生有相同生日么？
6、通用：任意大量输入
样例：给定任意n个学生的集合，有一对学生有相同生日么？
如果生日是365天中的一个，对于n>365，答案总是正确的。
假设生日的分辨率超过n

# 二、算法

1、程序映射每个输入到单个输出。
2、如果算法对于每个问题输入，都返回一个正确输出，那么算法解决了问题。
3、例子：一个解决生日匹配的算法
维护一个名字与生日的记录（初始化为空）。
以某种顺序，采访每个学生。如果生日存在记录中，返回找到的这对。否则把姓名生日加到记录里。
如果采访的最后一名学生没有成功，返回None。

# 三、正确性

1、程序/算法有固定尺寸，如何证明其正确性？
2、对于少量输入，可以使用例子分析。
3、对于任意大量输入，算法必须是以某种方式，递归的或者循环的。
4、必须使用推断（为什么递归是一个计算机科学中如此关键的理念）
5、样例：生日匹配算法正确性的证明：
k：记录中学生的数量
假设：如果前k个包含匹配，在采访学生k+1之前返回匹配结果。
base case：k=0，前k个不包含匹配
归纳法假设k=k'成立，考虑k=k'+1
如果前k'包含一个匹配，已经通过推断返回了一个匹配
否则前k'不包含匹配，所以如果前k'+1有匹配，那么匹配包含k'+1
然后算法直接检测，是否学生k'+1的生日存于前k'

# 四、效率

1、算法多快产生一个正确的输出
可以评估时间，但想性能是独立于机器的。
返回算法操作（固定时间）的次数。
期望依赖输入的尺寸，更大的输入需要更多的时间。
输入的尺寸通常称作n，但不总是如此。
有效的，对于给定输入，返回多项式时间。
对于某个问题，有时没有有效的算法。
2、渐进理念：忽略常量因子和低阶项
上边界(O)，下边界(Ω)，上界和下界(Θ)。
时间估算，基于每个时钟周期一个操作，1GHz的单核机器。

| input | constant    | logarithmic    | linear      | log-linear      | quadratic     | polynomial    | exponential               |
|:----- | ----------- | -------------- | ----------- | --------------- | ------------- | ------------- | ------------------------- |
| n     | $\Theta(1)$ | $\Theta(logn)$ | $\Theta(n)$ | $\Theta(nlogn)$ | $\Theta(n^2)$ | $\Theta(n^c)$ | $2^{\Theta(n^c)}$         |
| 1000  | 1           | $\approx10$    | 1000        | $\approx10,000$ | 1,000,000     | $1000^c$      | $2^{1000}\approx10^{301}$ |
| Time  | 1ns         | 10ns           | 1us         | 10us            | 1ms           | $10^{3c-9}$s  | $10^{281}$millenia        |

# 五、计算模型

1、声明，机器上的什么操作可在O(1)时间内执行。\
2、这类模型成为Word-RAM。\
3、Machine word：w位的块（w是w位Word-RAM的字尺寸）。\
4、内存：可寻址的一系列machine words。\
5、对于O(1)数量的字，处理器支持一些常量时间操作：

- 整数运算：(+，-，*，/，%)
- 逻辑操作符：(&&，||，！，==，<,>,<=,>=)
- 位运算：(&,|,<<,>>,...)
- 给定word a：可以读写地址a处的字

6、内存地址必须能够访问内存中的每一处：

- 需要：w>=#位来代表最大的内存地址，例如：$log_2n$
- 32位字，最大内存4GB；64位字，最大内存16EB

7、python是一个更复杂的计算模型，基于Word-RAM实现。

# 六、数据结构

1、数据结构是一个存储非常量数据方式，它支持一组的操作。
2、操作集合成为接口：
Sequence：项目外部有序（first、last、nth）
Set：项目内部有序（基于item的key查询）
3、数据结构可以用不同性能实现同样接口
4、例子：静态数组，固定槽位，固定长度，静态序列接口
StaticArray(n)：分配尺寸n的静态数组，用Θ(n)时间初始化为0
StaticArray.get_at(i)：返回存储在数组索引i处的word，用时Θ(1)
StaticArray.set_at(i, x)：把word x写到数组索引i处，用时Θ(1)
5、存储的word可以持有更大对象的地址
6、与Python tuple，set_at(i, x)相似，python list是一个动态数组

# 七、recitation

## 算法（algorithms）

&emsp;&emsp;算法研究是寻找有效解决问题的方法。本课的目的，不仅教你如何解决的问题，还教你告知别人：问题的解决方案是既正确、又高效的。
&emsp;&emsp;问题是一个二元关系：将输入和正确输出关联起来。
&emsp;&emsp;一个确定的算法，是一个将输入映射到一个输出上的程序。
&emsp;&emsp;一个算法解决一个问题，对于每个问题的输入，它返回正确的输出。
&emsp;&emsp;当问题输入有不止一个正确输出时，一个算法，应该仅对给定输入返回一个输出。举个例子，考虑这个问题：在复习课中，找到另外一个拥有同样生日的学生。
&emsp;&emsp;问题：在复习课的学生中，要么返回拥有同样生日、年份的两个学生，要么说明没有这种情况存在。
这个问题，将一个输入（你的复习课），与一个或多个输出（由生日匹配的学生对组成、或-1）关联 .一个问题的输入有时称作问题的实例。解决这个问题的算法如下：
&emsp;&emsp;算法：保留一个初始为空的学生姓名和生日的记录，遍历教室，询问每个学生的姓名和生日。采访完每个学生后，检查他们的生日是否已存在于记录中。如果已存在，返回两个学生的姓名。否则，将他们的姓名和生日添加到记录中。如果面试完所有学生后，没有满足的pair找到，返回没有满足的pair存在。
&emsp;&emsp;当然，我们的算法解决更通用的问题，比起上面提到的。同样的算法，可以在任意集合的学生中找到生日匹配的pair，而不仅仅是复习课中学生。在本课中，我们尝试解决问题（输入可以是任意大）。生日匹配算法可以被应用到任意尺寸的复习课。但我们如何确定这个算法是正确的、有效的？

## 正确性（correctness）

&emsp;&emsp;任何你写的计算机程序拥有有限尺寸，然而它作用的输入可以是任意大。因此本课中，我们讨论的每个算法，将需要重复算法中的命令，通过循环或递归。并且我们将能通过推断证明算法的正确性。让我们证明生日算法的正确性。
&emsp;&emsp;证明：前k个学生面试完了。基本情形：k=0，没有匹配对，算法返回没有匹配对。或者，假设算法对于前k个学生返回正确。如果前k个学生包含一个匹配对，那么k+1个学生也是如此，并且算法已经返回了一个匹配对。否则，前k个学生没有包含匹配对，所以如果k+1个学生包含一个匹配，那么这个匹配包含学生k+1，并且算法检查是否学生k+1有同样的生日，如同已经处理过的一样。

## 效率（efficiency）

&emsp;&emsp;什么让一个计算机程序有效？如果可以用更少的资源解决同样问题，那么一个程序比另外一个更有效。我们期望：更大输入可能花费更多时间解决，比起更小尺寸的输入。另外，程序使用的资源，例如存储空间、运行时间，将取决于使用的算法，以及实现的算法的机器。我们期望：更快机器上实现的算法，将比更慢机器上的相同算法，要更快，对于相同输入。我们想能够比较算法，无需关心机器多快。因此在本课中，我们比较算法，基于他们的渐进性能（与问题输入尺寸相关），为了忽略不同的硬件性能的常量因子。

## 渐进性理念（asymptotic notation）

&emsp;&emsp;我们可以使用渐进性理念来忽略常量（不会随问题输入的尺寸改变）。O(f(n))代表函数（在自然数域满足以下属性）集合。

        O理念：非负函数g(n)是O(f(n))，存在正实数c，和正整数n0，对于所有n>=n0，满足g(n)<=cf(n)。

        此定义为足够大的n的函数的渐近增长上界。即使，我们以恒定数量放缩或移动我们的函数，增长的界限也是对的。按照惯例，对人们来说，称函数g(n)是O(f(n))或等于O(f(n))是更常见的，但它们真正的含义是子集，g(n)\inO(f(n))。因此，由于我们的问题大小是cn，我们可以忽略c，并将输入大小称为O(n)。一个相似的理念可被用作下边界。

        $\Omega$理念：非负函数g(n)是$\Omega(f(n))$，存在正实数c和正整数n0，对于n>=n0，让cf(n)<=g(n)。

        当一个函数既上边界渐进、又下边界渐进另外一个函数，我们使用$\Theta$理念。当g(n)=$\ \Theta(f(n))$，我们称f(n)代表g(n)的严格上下限。

        $\Theta$理念：如果$g(n)\ \in$ $O(f(n))\cap$ $\Omega(f(n))$，非负函数g(n)是$\Theta(f(n))$。

        我们通常使用缩写来描述常见函数的渐进增长（例如：渐进复杂度），例如那些展示在下表中的。这里我们假设$c\in\Theta(1)$。

| shorthand      | Constant    | Logarithmic    | Linear      | Quadratic     | Polynomial    | Exponentia        |
| -------------- | ----------- | -------------- | ----------- | ------------- | ------------- | ----------------- |
| $\Theta(f(n))$ | $\Theta(1)$ | $\Theta(logn)$ | $\Theta(n)$ | $\Theta(n^c)$ | $\Theta(n^c)$ | $2^{\Theta(n^c)}$ |

  对解决问题来说，线性时间通常是必要的，为了解决问题，整个输入必须被读入。然而，如果输入已经可从内存访问，一些问题能以sub-linear时间被解决。例如，在有序数组（已经加载进内存）中找一个值的问题，可以通过二分查找，以对数时间解决。本课中，我们聚焦于polynomial。在logarithmic、linear和exponential之间有很大不同。

        如果n=1000，$logn\approx10$，n$\approx10^3$，然而$2^n\approx10^{300}$。为了比较，宇宙中原子的数量大约$10^{80}$。通常用变量n来代表参数（在问题输入尺寸中是线性的），尽管并非总是这种情况。例如，之后讨论的图算法，问题的输入将是一个图参数：点集合V和线集合E，因此自然数输入尺寸是：$\Theta(|V|+|E|)$。或者，当讨论矩阵算法时，通常n表示方阵的宽度，问题输入有尺寸$\Theta(n^2)$，表明n*n矩阵的每个元素。

## 计算模型（computation）

&emsp;&emsp;为了精确地计算算法使用的资源，我们需要模型化    一个计算机，花费多久来执行基本操作。明确这样一组操作，提供一个计算模型，我们可以把我们的分析基于这个计算模型。在本课中，我们将使用w-bit 字RAM计算模型（将计算机模型化为一个随机访问的机器字数组，称为内存），以及一个执行内存操作的处理器。一个机器字是一串w位，代表一个整数{0,…,$2^w-1$}。一个Word-RAM处理器，可以在常量时间内，执行两个机器字的基本二维操作，包括加、减、乘、除、取模、位操作、二进制比较。另外，给定字a，处理器可以用常量时间，读、或写内存中位于地址a的字。如果一个机器字仅包含w位，处理器将只能读、写，至多2w个内存地址。因此当解决输入为存储在n个机器字上的问题时，我们将总是假设我们的Word-RAM至少有w>$\log_2{n}$位，否则机器不能访问内存中的所有输入。为了让这个限制直观些，一个Word-RAM模型（可字节寻址的64位机器），允许输入尺寸高达$10^{10}$GB。

## 数据结构（data Structure）

&emsp;&emsp;我们生日匹配算法的执行时间，取决于我们存了多少个名字与生日的记录。数据结构是一种存储非固定数量数据的一种方式，支持一组操作来操作数据。这组被数据结构支持的操作称为接口。一些数据结构可能支持相同操作，但可能对于每种操作有着不同的性能。一些问题可以通过用恰当的数据结构存储数据，来解决。对于我们的例子，我们将使用最原始的数据结构（源于Word-RAM）：static-array。static-array是内存中简单的、连续的字序列，支持地序列接口：
&emsp;&emsp;StaticArray(n)：分配一个尺寸为n的新static array，初始化为0。用时$\Theta(n)$。
&emsp;&emsp;StaticArray.get_at(i)：返回存储在数组中，索引为i的元素。用时$\Theta(1)$。
&emsp;&emsp;StaticArray.set_at(i, x)：把字x写到数组索引为i的位置。用时$\Theta(1)$。
&emsp;&emsp;get_at(i)和set_at(i, x)操作执行时间为常量，因为数组中的每个元素有同样的尺寸：一个机器字。为了在数组中存储更大的对象，我们可以将数组中的机器字，解释为一个内存地址（指向更大的一块内存）。Python tuple类似static array（除了set_at(I, x)）。Python list实现dynamic array。

## 运行时间分析（running Time Analysis）

        现在让我们分析我们生日匹配算法（基于包含n个学生的习题课）的运行时间。我们将假设每个名字与生日占用常量个机器字，以至于单个学生信息可以被收集，并以常量时间操作。我们逐行看下代码。除了第8、9、11行，所有行花费常量时间。第8行花费$\Theta(n)$时间来初始化静态数组记录；第9行最多循环n次；第11行循环查看记录（record）中已存在的k个元素。因此这个算法的运行时间最多：

$O(n)+\sum_{k=0}^{n-1}(O(1)+k*O(1))=O(n^2)$

        这是n的平方，这是多项式的。这是有效的？不，我们可以通过为我们的记录使用一个不同的数据结构来做得更好。我们将花费本课程的前半部分学习基本的数据结构，每个数据结构将被订制，用于有效地支持一系列不同操作。

## 渐进性练习（asymptotics Exercises）

1、$\binom {n}{6006}$

分子：$n(n-1)...(n-6005)$，n的6006次方的多项式

分母：$6006!$，对于n来说是个常数

因此：$\binom {n}{6006}=\Theta(n^{6006})$

2、$log_{6006}{((log(n^{\sqrt{n}}))^2)}$

公式：$logab=loga+logb$，$log(a^b)=bloga$，$log_ab=logb/loga$

$log_{6006}{((log(n^{\sqrt{n}}))^2)}=\dfrac{2}{log6006}log(\sqrt{n}logn)=\Theta(logn^{1/2}+loglogn)=\Theta(logn)$

3、$2^{n+1}\in\Theta(2^n)，2^{2^{n+1}}\notin\mathcal{O}(2^{2n})$

$2^{n+1}=2*2^n$，常量乘$2^n$还是$2^n$

$2^{2^{n+1}}=(2^{2n})^2$，$2^{2n}$并非一个常量

4、对于所有正数a、b，$(logn)^a=\mathcal{O}(n^b)$

$\lim\limits_{n \to \infty}log(\dfrac{n^b}{(logn)^a})=\lim\limits_{n \to \infty}(blogn-aloglogn)=\lim\limits_{x \to \infty}(bx-alogx)=\infty$

5、$(logn)^{logn}=\Omega(n)$

因为：$m^m=\Omega(2^m)$，令$n=2^m$，所以m=logn，得以证明

6、$(6n)!\notin\Theta(n!)$，但$log((6n)!)\in\Theta(log(n!))$

Sterling’s近似法：

$n!=\sqrt{2\pi n}(\dfrac{n}{e})^n(1+\Theta(\dfrac{1}{n}))$

# 八、problem session1

## 1-1函数的渐进性

对于下面5个函数集合中每一个，对它们进行排序。如果在序列中，$f_a$出现在$f_b$之前，那么$f_a=\mathcal{O}(f_b)$。如果$f_a=\mathcal{O}(f_b)$且$f_b=\mathcal{O}(f_a)$，意味着$f_a$和$f_b$可以任何顺序出现，可以用花括号把$f_a和f_b$围起来表明这种情况。例如，如果多个函数为：

$f_1=n，f_2=\sqrt{n}，f_3=n+\sqrt{n}$

正确的答案是：$(f_2,\{ f_1 , f_3 \} )或(f_2,\{ f_3 , f_1 \} )$

a) $f_1=(logn)^{2019}，f_2=n^2log(n^{2019})，f_3=n^3，f_4=2.019^n，f_5=nlogn$

$f_1,f_5,f_2,f_3,f_4$

b) $f_1=2^n,f2=n^3,f_3=\binom{n}{n/2},f_4=n!,f_5=\binom{n}{3}$

$\{f_2,f_5\},f_3,f_1,f_4$

## 1-2队列基本操作

 给定一个数据结构D，支持4个 first/last 序列操作：

D.insert_first(x)，D.delete_first()，D.insert_last(x)，D.delete_last()

每个操作都是$\mathcal{O}(1)$，描述算法：用低级操作方法来实现下面高级操作。

删除操作返回删除的元素。

(a) swap_ends(D):以$\mathcal{O}(1)$复杂度交换序列中第一个和最后一个元素。

first = D.delete_first()

end = D.delete_last()

D.insert_first(end)

D.insert_last(first)

(b)shift_left(D,k):以$\mathcal{O}(k)$复杂度把前k个元素按顺序移动到序列末尾，移动完后，之前序列中的第k个元素成为末尾，之前序列中的第k+1个元素成为序列之首。

for(int i=0; i < k; i++) {

    tmp = D.delete_first();

    D.insert_last(tmp)

}

## 1-3双端队列操作

动态数组可以实现一个序列接口，支持最坏情形$\mathcal{O}(1)$时间索引（根据角标i找到对应元素），以及从数组后面插入、删除item是可变常量时间（插入n个item，时间为$\mathcal{O}(n)）$。然而在动态数组前面插入和删除，并非足够有效的，因为每个entry必须移动来保持序列所有entry的有序性，花费线性时间。

另一方面，链表数据结构，在两端都可以最坏情形$\mathcal{O}(1)$支持插入、删除操作，但代价是线性时间查找。

我们可以两个好处都占：设计一个数据结构来存储一系列的item，支持最坏情形$\mathcal{O}(1)$时间索引查找，以及可摊还$\mathcal{O}(1)$时间在两端插入和删除。你的数据结构应该使用$\mathcal{O}(n)$空间来存储n个item。

# 九、problem set0

(n i)表示n个数中取i个数，公有多少种组合
E(x)表示数学期望值
|A-B|表示，集合A中有，集合B中无的元素个数